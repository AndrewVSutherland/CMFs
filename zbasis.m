Attach("chars.m");

intrinsic NFPolyIsIsomorphic (f::RngUPolElt,g::RngUPolElt) -> BoolElt
{ Determines whether the specified polynomials are monic irreducible elements of Q[x] that define the same number field. }
    if Degree(f) ne Degree(g) then return false; end if;
    if not (IsMonic(f) and IsMonic(g)) then return false; end if;
    if not (IsIrreducible(f) and IsIrreducible(g)) then return false; end if;
    Rf<t>:=PolynomialRing(NumberField(f));
    return #Roots(Rf!Coefficients(g)) gt 0; // if g has a root in Q[x]/(f) then Q[x]/(g) is contained in Q[x]/(f) and we have equality because degrees match
end intrinsic;

intrinsic NFPolyIsIsomorphic (f::SeqEnum,g::SeqEnum) -> BoolElt
{ Determines whether the specified sequences specify irreducible polynomials that define the same number field. }
    R<x> := PolynomialRing(Rationals());
    return NFPolyIsIsomorphic (R!f,R!g);
end intrinsic;

intrinsic OptimizedOrderBasis(KPoly::SeqEnum,ZSeq::SeqEnum[SeqEnum]) -> 
    SeqEnum[RngInt], SeqEnum[SeqEnum[RngIntElt]], SeqEnum[SeqEnum[RngIntElt]],  RngIntElt, RngIntElt, BoolElt
{ Given the coefficients of an irreducible monic polynomial f in Q[x] and a sequence of algebraic integers in the number field Q[x]/(f(x)) specified in terms of the power basis, returns:
    (1) list of integer coefficients of an optimized monic poly for K;
    (2) list of lists of integers giving an optimized basis for the order O generated by Zvals;
    (3) list of list of lists integers specifying expressing input sequence in terms of optimized basis;
    (4) integer dividing the index of O in the ring of integers OK;
    (5) integer equal to disc(OK) if [OK:O] is known, zero otherwise;
    (6) boolean value set to true if the canonical polredabs polynomial defining K was used. }
    
    require KPoly[#KPoly] eq 1: "First argument must specify the coefficients of a monic polynomial";
    deg := #KPoly-1;
    require &and[#z eq deg:z in ZSeq]: "Second argument must be a list of lists each of length 1 less then length of first argument";

    if deg eq 1 then return [1,0],[[1]], ZSeq, GCD([z[1]:z in ZSeq]), 1; end if;
    
    R<x>:=PolynomialRing(Rationals());
    K := NumberField(R!KPoly);

    Z := Matrix(Rationals(),ZSeq);

    // Make best field
    bestpoly, fbestroot, ispolredabs := PolredbestifyWithRoot(R!KPoly);  // iotaK is the isomorphism from Kabs_notbest to Kabs
    Kbest := NumberField(bestpoly);
    fbestroot := fbestroot cat [0 : i in [1..Degree(bestpoly)-#fbestroot]];
    iotabest := hom<K->Kbest | fbestroot>;

    // Change of power basis from K to Kbest (so deg x deg)
    Pbest := Matrix([Eltseq(iotabest(K.1^i)) : i in [0..Degree(K)-1]]);
    Zbest := Z*Pbest;
    
    // Verify all is well
    assert &and[K!Eltseq(Z[m]) eq (iotabest^-1)(Kbest!Eltseq(Zbest[m])) : m in [1..Nrows(Z)]];

    // make order over ZZ generated by T_n's
    O := Order([Kbest | Kbest!Eltseq(Zbest[i]) : i in [1..Nrows(Zbest)]]);
    OBasis := Basis(O);  
    assert #OBasis+1 eq #KPoly;

    discOK := 0;
    // Improve O as much as possible to get a divisor of the index
    Obest := O;  // Initialize best order to O
    discO := Discriminant(O);
    if ispolredabs then
        for p in PrimeDivisors(discO) do
            Obest := pMaximalOrder(Obest, p);
        end for;
        discOK := Discriminant(Obest);
        _, Oindex := IsSquare(discO/discOK);
    else
        ps, hard := TrialDivision(discO, 10^7);
        for pdat in ps do  // make p-maximal
            Obest := pMaximalOrder(Obest, pdat[1]);
        end for;
        hard := [ PerfectPowerBase(m) : m in hard];
        notsohard := [ m : m in hard | m le 10^80 or IsProbablePrime(m) ];
        for m in notsohard do
            for p in PrimeDivisors(m) do  // make p-maximal
                Obest := pMaximalOrder(Obest, p);
            end for;
        end for;
        if #notsohard eq #hard then
            discOK := Discriminant(Obest);
            _, Oindex := IsSquare(discO/discOK);
        else
            _, Oindex := IsSquare(discO/Discriminant(Obest));
        end if;
    end if;

    PO := Matrix([Eltseq(Kbest!b) : b in OBasis]);
    // PO is the change of basis matrix from Magma's integral basis to the power basis
    POinv := PO^-1;

    ZO := ChangeRing(Zbest*POinv,Integers());  

    // Now compute a small basis
    try
        Olat, mOlat := MinkowskiLattice(O);   // use default precision
        _, E := LLL(Olat);                    // E is the ZZ-change of basis to an LLL-reduced basis
    catch e
        Olat, mOlat := MinkowskiLattice(O : Precision := Max(100,Round(Log(10,AbsoluteValue(Discriminant(Kbest)))))); // note this is not disc(OK)
        _, E := LLL(Olat);
    end try;      
  
    // Theorem: The shortest vectors of Olat are the roots of unity.
    EinO := [O!Eltseq(e) : e in Rows(E)];
    muEinO := [e : e in EinO | Abs(Norm(mOlat(e))-deg) lt 10^(-Precision(BaseRing(Olat))*9/10) and e notin [1,-1]];
    v := InfinitePlaces(Kbest)[1];
    CC := Parent(Evaluate(Kbest!1,v));
    pi := Pi(CC);
    muexps := [Roots(PowerRelation(Argument(Evaluate(z,v))/(2*pi),1),Rationals()) : z in muEinO]; // recognize as exp(2*pi*i*mu) with mu in QQ
    muexpshasroots := [i : i in [1..#muexps] | #muexps[i] gt 0];  // pick out ones where a good match was found
    if #muexpshasroots gt 0 then
        muEinO := [muEinO[i] : i in muexpshasroots];
        muexps := [muexps[i][1][1] : i in muexpshasroots];
        m := Lcm([Denominator(k) : k in muexps]);   // candidate denominator
        mus := [z : z in muEinO | z^m eq 1];
        if sub<Kbest | ChangeUniverse(mus,Kbest)> eq Kbest and O eq sub<O | mus> then
            // cyclotomic ring!  Find a combination giving a primitive root of unity to get power basis
            gcd, lincombo := Xgcd([Integers() | m*k : k in muexps]);
            assert gcd eq 1;
            zgen := &*[muEinO[i]^(lincombo[i]) : i in [1..#lincombo]];
            assert O eq sub<O | [zgen^k : k in [0..deg-1]]>;
            E := Matrix(Integers(), [Eltseq(O!zgen^k) : k in [0..deg-1]]);
        end if;
    end if;

    // ensure the first basis vector is 1
    Erows := [Eltseq(v) : v in Rows(E)];
    ind := Index(Erows,Eltseq(O!1));
    // Corollary: If 1 is not in a basis of shortest vectors, then 
    //    Olat is spanned additively by roots of unity, so Olat is the maximal
    //    order in a cyclotomic field.
    assert ind ne 0;
    E := Matrix([Erows[ind]] cat Erows[1..(ind-1)] cat Erows[(ind+1)..#Erows]);
  
    Einv := E^-1;
    OLLLBasis := [&+[ E[i][j]*OBasis[j] : j in [1..deg]] : i in [1..deg]];
    ZOE := ZO*Einv;

    // check that seqs match
    assert &and[Kbest!Eltseq(Zbest[m]) eq Kbest!&+[ZOE[m][i]*OLLLBasis[i] : i in [1..deg]] : m in [1..Nrows(Z)]];

    OBestBasis := [Eltseq(Kbest!c) : c in OLLLBasis];
    assert OBestBasis[1] eq Eltseq(Kbest!1);

    return Eltseq(MinimalPolynomial(Kbest.1)), OBestBasis, [[r[i]:i in [1..#OBestBasis]]:r in Rows(ZOE)], Integers()!Oindex, Integers()!discOK, ispolredabs; 
end intrinsic;

intrinsic NFSeq (KPoly::SeqEnum,  OBasis::SeqEnum[SeqEnum], Seq::SeqEnum[SeqEnum]) -> SeqEnum[FldNum]
{ Given poly coefficients defining a number field K, a Z-basis for an order O in O_K, and a sequence of elements of O specified as vectors in this base, returns the corresponding sequence of algebraic integers as elements of K. }
    R<x> := PolynomialRing(Rationals());
    K<a> := NumberField(R!KPoly);
    return [K!Eltseq(r) : r in Rows(Matrix(Rationals(),Seq)*Matrix(Rationals(),OBasis))];
end intrinsic;

intrinsic NFSeqIsIsomorphic (KPoly1::SeqEnum,Seq1::SeqEnum[SeqEnum], KPoly2::SeqEnum, Seq2::SeqEnum[SeqEnum]) -> BoolElt, SeqEnum[FldRatElt]
{ Given two sequences that both contain a basis for the same number specified in terms of (possibly different) power bases, determine if there is a field isomorphism that maps one sequence to the other.  If returns the image of first power basis generator in the second. }
    if not NFPolyIsIsomorphic(KPoly1,KPoly2) then return false,_; end if;
    require {#a:a in Seq1} eq {#KPoly1-1} and {#a:a in Seq2} eq {#KPoly2-1}: "Specified sequences do not define Q-vectors of the correct dimension";
    if #KPoly1 eq 2 then if Seq1 eq Seq2 then return true,[1]; else return false,_; end if; end if;
    d := #KPoly1-1;
    V := VectorSpace(Rationals(),d);
    B:=[]; I:=[]; s:=0;
    for i:=1 to #Seq1 do
        if Dimension(sub<V|B,[Seq1[i]]>) gt s then
            Append(~I,i); Append(~B,Seq1[i]);
            s+:=1;
            if s eq d then break; end if;
        end if;
    end for;
    if s lt d then error "Specified sequence does not contain a Q-basis for the specified number field"; end if;
    B1 := Matrix(Rationals(),[Seq1[i]:i in I]);
    B2 := Matrix(Rationals(),[Seq2[i]:i in I]);
    T := B1^-1*B2;
   if Matrix(Rationals(),Seq1)*T ne Matrix(Rationals(),Seq2) then return false,_; end if;
    v := [0:i in [1..d]];  v[2] := 1;
    v := Vector(Rationals(),v) * T;
    R<x> := PolynomialRing(Rationals());
    K1 := NumberField(R!KPoly1);  K2 := NumberField(R!KPoly2);
    pi := hom<K1->K2|K2!Eltseq(v)>;
    TT := Matrix(Rationals(),[Eltseq(pi(K1.1^n)): n in [0..d-1]]);
    if T eq TT then return true, Eltseq(v); else return false,_; end if;
end intrinsic;

intrinsic NFSeqIsIsomorphic (KPoly1::RngUPolElt,Seq1::SeqEnum[SeqEnum], KPoly2::RngUPolElt,Seq2::SeqEnum[SeqEnum]) -> BoolElt, SeqEnum[FldRatElt]
{ Given two sequences that both contain a basis for the same number specified in terms of (possibly different) power bases, determine if there is a field isomorphism that maps one sequence to the other.  If returns the image of first power basis generator in the second. }
    return NFSeqIsIsomorphic(Eltseq(KPoly1),Seq1,Eltseq(KPoly2),Seq2);
end intrinsic;        

intrinsic NFSeqIsIsomorphic (Seq1::SeqEnum,Seq2::SeqEnum) -> BoolElt, FldNumElt
{ Given two sequences that both contain a basis for the same number specified in terms of (possibly different) power bases, determine if there is a field isomorphism that maps one sequence to the other.  If returns the image of first power basis generator in the second. }
    require #Seq1 gt 0 and #Seq1 eq #Seq2: "Sequences must be non-empty and of the same length";
    K1 := AbsoluteField(NumberField(Parent(Seq1[1])));  K2:= AbsoluteField(NumberField(Parent(Seq2[2])));
    f1 := DefiningPolynomial(K1); f2 := DefiningPolynomial(K2);
    if Type(f1) eq SeqEnum and #f1 eq 1 then f1 := f1[1]; end if;
    if Type(f2) eq SeqEnum and #f2 eq 1 then f2 := f2[1]; end if;
    b,v := NFSeqIsIsomorphic(Eltseq(f1), [Eltseq(K1!a):a in Seq1],Eltseq(f2),[Eltseq(K2!a):a in Seq2]);
    if b then return true,K2!v; else return false,_; end if;
end intrinsic;

function CompareCCLists(a,b)
    for i:=1 to #a do
        if Real(a[i]) lt Real(b[i]) then return -1; end if;
        if Real(a[i]) gt Real(b[i]) then return 1; end if;
        if Imaginary(a[i]) lt Imaginary(b[i]) then return -1; end if;
        if Imaginary(a[i]) gt Imaginary(b[i]) then return 1; end if;
    end for;
    return 0;
end function;

// Round real and imaginary parts of complex number z to accuracty of 1/absprec (so values within 1/(2*absprec) will come out the same)
function roundCC(z,absprec)
    return Round(absprec*Real(z))/absprec + Round(absprec*Imaginary(z))/absprec * Parent(z).1;
end function;

intrinsic LabelEmbeddings (a::SeqEnum[FldNumElt], L::SeqEnum[RngIntElt]: Precision:=100) -> SeqEnum[SeqEnum[RngIntElt]]
{ Given a sequence of elements a of number field K and a sequence of integers n indexed by embeddings of K, returns a list of unique labels for the embeddings of K
  in which each label is a pair [n,i] with i=1,2,3,.. chosen according to the lex ordering of the embeedings of a, where complex numbers are lex ordered by read and imagainary parts. }
    require #L eq Degree(Parent(a[1])): "List L must have length equal to the degree of the number field in which the sequence a lies.";
    require #{Multiplicity(Multiset(L),n):n in L} eq 1: "Each distinct entry in L must occur with the same multiplicity.";
    d := #L;  m := ExactQuotient(d,#Set(L));
    if m eq 1 then return [[L[i],1]:i in [1..d]]; end if;
    S := [<Conjugates(n:Precision:=Precision)[1]>:n in L];
    n := 0;
    while #Set(S) lt d do
        n +:= 1;
        if a[n] eq 0 or Degree(MinimalPolynomial(a[n])) eq 1 then continue; end if;
        c := Conjugates(a[n]:Precision:=Precision+10);
        c := [roundCC(x,10^(Precision)):x in c];
        if #Set(c) ne Degree(MinimalPolynomial(a[n])) or #Set(Multiplicities(Multiset(c))) ne 1 then Sprintf("Insufficient precision %o specified in function LabelEmbeddings, you need to increase it.", Precision); end if;
        S := [Append(S[i],c[i]):i in [1..d]];
    end while;
    S,s := Sort(S,func<a,b|CompareCCLists(a,b)>);
    T := [i:i in [1..d]]^s;
    LL := [*[L[i],0]:i in [1..#L]*];
    n := 1;
    for i:= 1 to d do
        if n gt m then n:=1; end if;
        j := T[i];
        LL[j] := [L[j],n];
        n +:= 1;
    end for;
    return LL;
end intrinsic;

